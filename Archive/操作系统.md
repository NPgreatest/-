## 进程vs线程vs协程

### 进程的:用户空间vs内核空间

* 用户空间：地址从低端到高端

  组成：代码段：程序的可执行代码

  ​			数据段：全局变量，静态变量等

  ​			堆：存放malloc，new出来的数据

  ​			用户栈：局部变量，返回地址等

* 内核空间：地址从高到低

​		组成：内核代码和数据(共享)

​					进程相关的数据结构(每个进程独有)：页表数据结构（虚拟内存管理），Task数据结构（进程状态，PCB{处理机状态、进程控制、调度信息}等），Area数据结构(映射文件、内存保护等)

**OS使用虚拟内存管理技术来安排这些共享和独有的部分。虚拟内存为每个进程提供了一种看似独立的内存视图。**

### 定义

进程是资源管理的基本单位，每个进程拥有独立的虚拟内存空间、文件描述符、安全凭证等资源。

线程是CPU调度的基本单位，线程运行在进程的上下文中，共享相同进程的资源（如虚拟内存）。

### 进程和线程比较

进程和线程的关系：进程是一个运行中的程序的实例。它提供了程序运行所需的环境，包括内存空间、系统资源等。线程是进程内的执行单位，可以理解为进程进行任务处理的实际“执行者”。

### 上下文切换

* 进程上下文切换(当线程进行切换时，如果线程属于不同的进程)：把资源都保存起来写回到内存中，等下次这个进程被调度时再把这些资源再加载到寄存器和高速缓存硬件。

进程上下文切换保存的内容有：

页表 -- 对应虚拟内存资源

文件描述符表/打开文件表 -- 对应打开的文件资源

寄存器 -- 对应运行时数据

信号控制信息/进程运行信息

* 线程的上下文切换只需要保存线程的一些运行时的数据，比如

线程的id

寄存器中的值

栈数据

### fork()与clone()

* 利用fork系统调用来创建一个子进程。fork所创建的子进程会复制父进程的虚拟地址空间。

对于复制的补充：fork刚创建的子进程采用了共享的方式，只用指针指向了父进程的物理资源。当子进程真正要对某些物理资源写操作时，才会真正的复制一块物理资源来供子进程使用。

* clone是一个轻量级的fork，用于创建新的进程或线程。允许更精细的控制哪些资源应该被共享。例如，它可以用来创建共享同一个地址空间、文件系统资源、文件描述符等的线程，或者创建有自己独立地址空间的进程。

### 僵尸进程vs孤儿进程

* 僵尸进程(已结束)：父进程没有调用wait()或者忽略了子进程的终止状态，子进程的进程描述符保留在操作系统中。
* 孤儿进程(正在进行)：父进程终止后，子进程没有被其他进程收养。会被系统init收养

### 堆和栈的区别

**堆空间存在于进程**：是共享的。在一个进程中，所有线程共享相同的堆空间。由于内存动态分配，不严格有序，所以叫做堆(与栈的有序性形成对比)

**栈空间存在于线程**：是独立的。每个线程有自己的栈空间，用于存储该线程的局部变量、函数调用记录等。严格有序，后进后出，与函数调用行为类似。

### 大端vs小端

* 大端(符合人类阅读数字习惯)：多字节值的高位字节存储在低地址上，而低位字节存储在高地址上。这意味着数据的“头部”位于地址最低的位置。

* 小端(x86)：多字节值的低位字节存储在低地址上，而高位字节存储在高地址上。这意味着数据的“尾部”位于地址最低的位置。
