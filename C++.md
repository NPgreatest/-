#### 虚函数表，动态多态

* 虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。

* 虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。

当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。

在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。

虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。

#### final关键字

放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载

#### 左值引用&右值引用

- 左值引用绑定到左值，即表达式结束后依然存在的对象；左值通常是持久的，有明确的内存地址；左值引用不能绑定到临时对象（即右值）。`int& ref = x;`

- 右值引用绑定到右值，即表达式结束后就不再存在的临时对象。 `int&& rref = 5; `
- 通过右值引用，C++允许我们在不需要一个对象的副本时直接使用它的数据，从而支持移动语义和优化。

#### malloc

**方式1：**当用户分配的内存小于128KB时通过brk()系统调用从堆分配内存，实现方式：将堆顶指针向高地址移动，获取内存空间，如果使用free释放空间，并不会将内存归还给操作系统，而是会缓存在malloc的内存池中，待下次使用

**方式2：**当用户分配的内存大于128KB时通过mmap()系统调用在文件映射区域分配内存，实现方式为：使用私有匿名映射的方式，在文件映射区分配一块内存，也就是从文件映射区拿了一块内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正释放

#### explicit & implicit

- Implicit：发生时不需要程序员直接指定转换类型；通常发生在赋值、函数调用等场合，编译器自动进行类型转换。

- Explicit：需要程序员明确指定要进行的类型转换；使用`explicit`关键字声明的构造函数或转换运算符不能用于隐式类型转换。

