#### 进程vs线程vs协程

#### 进程的:用户空间vs内核空间

* ==用户空间：地址从低端到高端==

  代码段：编译好的二进制机器码，加载到内存中

  数据段：全局变量，静态变量等(指定初始值)

  BSS 段：全局变量，静态变量等(未指定初始值)

  堆：存放malloc，new出来的数据(动态申请的内存) **地址：低$\rightarrow$高**

  文件映射与匿名映射区：动态链接库、mmap 系统调用映射的共享内存区 **地址：高$\rightarrow$低***

  用户栈：局部变量，返回地址等 **地址：高$\rightarrow$低**

* ==内核空间：地址从高到低==

​		组成：内核代码和数据(共享)

​					进程相关的数据结构(每个进程独有)：页表数据结构（虚拟内存管理），Task数据结构（进程状态，PCB{处理机状态、进程控制、调度信息}等），Area数据结构(映射文件、内存保护等)

<img src="D:\Work\1513-Leetcode\八股\pic\32-Linux.webp" alt="32-Linux" style="zoom:50%;" />

**OS使用虚拟内存管理技术来安排这些共享和独有的部分。虚拟内存为每个进程提供了一种看似独立的内存视图。**

注：32位Linux中3GB/1GB的比例划分是每个进程自己看到的视图，而实际的物理内存中是按照分页存储的，没有任何逻辑段的区分。

#### 线程进程定义(宏观上)

进程是资源管理的基本单位，每个进程拥有独立的虚拟内存空间、文件描述符、安全凭证等资源。

线程是CPU调度的基本单位，线程运行在进程的上下文中，共享相同进程的资源（如虚拟内存）。

#### 进程和线程比较

进程和线程的关系：进程是一个运行中的程序的实例。它提供了程序运行所需的环境，包括内存空间、系统资源等。线程是进程内的执行单位，可以理解为进程进行任务处理的实际“执行者”。

==子进程共享了父进程的虚拟内存空间，这样子进程就变成了我们熟悉的线程，**是否共享地址空间几乎是进程和线程之间的本质区别。Linux 内核并不区别对待它们，线程对于内核来说仅仅是一个共享特定资源的进程而已**。==

在Linux操作系统中，线程和进程都是同样的数据结构`task_stuct`。专门描述进程虚拟地址空间的内存描述符 mm_struct 结构

* **对于进程来说**，每个进程都有自己独立的`mm_struct`实例。子进程与父进程通过写时复制优化
* **对于线程来说**，同一进程内的所有线程共享相同的`mm_struct`实例，因为它们共享同一虚拟地址空间。

```C
struct task_struct {
        // 进程id
	    pid_t				pid;
        // 用于标识线程所属的进程 pid
	    pid_t				tgid;
        // 进程打开的文件信息
        struct files_struct		*files;
        // 内存描述符表示进程虚拟地址空间
        struct mm_struct		*mm;
		// ......
}
```

#### 线程组tgid, 进程线程辨析

概览：tgid用于标识一个进程下的同一组线程。在进程创建新线程时，tgid相同，用于表示在同一组

创建一个新的进程会给一个新的PID和TGID，并且2个值相同，
当创建一个新的线程的时候，会给你一个新的PID，并且TGID和之前开始的进程一致。

```shell
                         USER VIEW
                         vvvv vvvv
              |          
<-- PID 43 -->|<----------------- PID 42 ----------------->
              |                           |
              |      +---------+          |
              |      | process |          |
              |     _| pid=42  |_         |
         __(fork) _/ | tgid=42 | \_ (new thread) _
        /     |      +---------+          |       \
+---------+   |                           |    +---------+
| process |   |                           |    | process |
| pid=43  |   |                           |    | pid=44  |
| tgid=43 |   |                           |    | tgid=42 |
+---------+   |                           |    +---------+
              |                           |
<-- PID 43 -->|<--------- PID 42 -------->|<--- PID 44 --->
              |                           |
                        ^^^^^^ ^^^^
                        KERNEL VIEW
```

所以说区分线程和进程有两种方式:

**通过`mm_struct`共享情况来区分**：一种是线程之间的mm_struct是一样的，都共享进程的虚拟内存。

**通过PID和TGID的关系来区分**：只要tgid不等于pid，那么它就是线程。如果相等，那么就是主线程/进程

#### 内核线程

内核线程和用户态线程的区别就是内核线程没有相关的内存描述符 mm_struct ，内核线程对应的 task_struct 结构中的 mm 域指向 Null，所以内核线程之间调度是不涉及地址空间切换的。

#### mm_struct

尤其在进程虚拟内存空间中包含的内存区域 VMA 比较多的情况下，使用红黑树查找特定虚拟内存区域的时间复杂度是 O( logN ) ，可以显著减少查找所需的时间。

所以在内核中，同样的内存区域 vm_area_struct 会有两种组织形式，一种是双向链表用于高效的遍历，另一种就是红黑树用于高效的查找。

<img src="D:\Work\1513-Leetcode\八股\pic\mm_struct.webp" alt="mm_struct" style="zoom:50%;" />



#### 上下文切换

* 进程上下文切换(当线程进行切换时，如果线程属于不同的进程)：把资源都保存起来写回到内存中，等下次这个进程被调度时再把这些资源再加载到寄存器和高速缓存硬件。

进程上下文切换保存的内容有：

页表 -- 对应虚拟内存资源

文件描述符表/打开文件表 -- 对应打开的文件资源

寄存器 -- 对应运行时数据

信号控制信息/进程运行信息

* 线程的上下文切换只需要保存线程的一些运行时的数据，比如

线程的id

寄存器中的值

栈数据

#### 僵尸进程vs孤儿进程

* 僵尸进程(已结束)：父进程没有调用wait()或者忽略了子进程的终止状态，子进程的进程描述符保留在操作系统中。
* 孤儿进程(正在进行)：父进程终止后，子进程没有被其他进程收养。会被系统init收养

#### 堆和栈的区别

**堆空间存在于进程**：是共享的。在一个进程中，所有线程共享相同的堆空间。由于内存动态分配，不严格有序，所以叫做堆(与栈的有序性形成对比)

**栈空间存在于线程**：是独立的。每个线程有自己的栈空间，用于存储该线程的局部变量、函数调用记录等。严格有序，后进后出，与函数调用行为类似。

#### 大端vs小端

* 大端(符合人类阅读数字习惯)：多字节值的高位字节存储在低地址上，而低位字节存储在高地址上。这意味着数据的“头部”位于地址最低的位置。

* 小端(x86)：多字节值的低位字节存储在低地址上，而高位字节存储在高地址上。这意味着数据的“尾部”位于地址最低的位置。

#### 进程调度算法

先来先服务；短作业W优先；最高相应比优先$优先权=\frac{等待时间+服务时间}{服务时间}$；时间片轮转；最高优先级（DIY设定）

多级反馈队列调度：设置了多个队列，赋予每个队列不同的优先级，每个**队列优先级从高到低**，同时**优先级越高时间片越短**；==对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间。**==

#### 页面置换算法

* 最佳置换算法：理论最佳，用来进行评价其它算法
* 先进先出置换算法：总是淘汰最先进入内存的页面，但与进程实际运行的规律不相适应
* LRU 置换算法：选择现有页面中t 值最大的，即最近最久未使用的页面淘汰(寄存器或栈)
* 最少使用置换算法：最近时期使用最少的页面作为淘汰页。(移位寄存器)
* Clock(最近未用) 置换算法：像钟表一样旋转指针，淘汰掉最近未被访问，且未被修改的。并且旋转的过程中把访问位置为0



#### IO多路复用

* select: 最多能处理fd的数量：1024（固定大小的数组）

当唤醒lop thread时，需要遍历一轮fd列表，时间复杂度O(N)。每次调用select函数时都需要拷贝一遍需要的列表。

* poll: 改进：不限制fd的数量，但是时间复杂度仍为O(N)
* epoll: 时间复杂度降为O(1)，创建池子和添加fd操作解耦，实现了池中fd复用，降低用户态和内核态之间数据拷贝成本。

epoll_create: 在内核开辟空间，创建一个epoll池子批量管理fd.

epoll_ctl: 对epoll池子中的fd进行增删改，并且提前声明好关心的时间(epoll_event)

epoll_wait: 在指定的epoll_event发生时唤醒。

存储fd：红黑树：对fd的增删改的时间复杂度是$O(logN)$，在有fd就绪时，会将其添加到就绪列表中。

就序列表：采用双向列表存储，在内核把多个poll_event封装到就序列表后，将列表通过epoll_wait返回，程序遍历列表进行处理。





# Linux

#### 微内核 vs 宏内核

**宏内核**：Linux 的内核是一个完整的可执行程序，且拥有最高的权限。

宏内核的特征是系统内核的所有模块，比如进程调度、内存管理、文件系统、设备驱动等，都运行在内核态。

**微内核**：微内核架构的内核只保留最基本的能力，比如进程调度、虚拟机内存、中断等，把一些应用放到了用户空间，比如驱动程序、文件系统等。

#### 文件映射

将磁盘上的文件内容映射到进程的地址空间。文件内容可以被当做内存中的数据来访问，从而避免了使用读写系统调用的开销。

对于大文件，采用惰性加载的策略。只有当程序实际访问到文件的某个部分时，该部分内容才会被加载到内存中。（虚拟内存和页面交换技术）

#### 匿名映射区

进程间共享内存通信中数据存储的位置。

#### 64位 -  canonical address 空洞

高16位全为0的地址空间是用户态，全为1是内核态。

如果有0有1，那么说明地址空间在空洞内，访问非法。用于分割内核和用户

<img src="D:\Work\1513-Leetcode\八股\pic\canonical.webp" alt="canonical" style="zoom:50%;" />

#### fork, vfork, clone

* 利用fork系统调用来创建一个子进程。fork所创建的子进程会复制父进程的虚拟地址空间。

对于复制的补充：fork刚创建的子进程采用了共享的方式，只用指针指向了父进程的物理资源。当子进程真正要对某些物理资源写操作时，才会真正的复制一块物理资源来供子进程使用。

* vfork相比fork更轻量级，虚拟地址空间与父进程完全共享。

* clone是一个轻量级的fork，用于创建新的进程或线程。允许更精细的控制哪些资源应该被共享。例如，它可以用来创建共享同一个地址空间、文件系统资源、文件描述符等的线程，或者创建有自己独立地址空间的进程。
