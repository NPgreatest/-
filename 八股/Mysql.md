

### 联合索引

建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。

$\text{区分度}=\frac{\text{distinct}(column)}{count(*)}$

### NULL

NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式中**至少会用 1 字节空间存储 NULL 值列表**

![null](D:\Work\八股笔记\pic\null.webp)

### Extra参考指标

- Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。
- Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。
- Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。



### 数据页

当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。

数据页之间不需要是物理上的连续的，而是逻辑上的连续。

<img src="D:\Work\1513-Leetcode\Archive\pic\数据页.webp" alt="数据页" style="zoom:80%;" />

<img src="D:\Work\1513-Leetcode\Archive\pic\数据页2.webp" alt="数据页2" style="zoom:80%;" />

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。



### B+树

![B+](D:\Work\1513-Leetcode\Archive\pic\B+.webp)

- 只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过分层来降低每一层的搜索量；
- 所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；

B树非叶子节点可以存储数据，适合大量读取时使用，MongoDB大量基于单个字段或字段组合查询，查询后端。

B+树因为叶子节点有指针相连适合**范围查询**，排序操作和数据库的存储和管理。

由于关系型数据库和非关系型数据的设计方式上的不同。导致在关系型数据中，遍历操作比较常见，因此采用B+树作为索引，比较合适。而在非关系型数据库中，单一查询比较常见，因此采用B树作为索引，比较合适。



### 事务的特性

- **原子性（Atomicity）**：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行过一样，就好比买一件商品，购买成功时，则给商家付了钱，商品到手；购买失败时，则商品在商家手中，消费者的钱也没花出去。
- **一致性（Consistency）**：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。
- **隔离性（Isolation）**：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。
- **持久性（Durability）**：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

- 持久性是通过 redo log （重做日志）来保证的；

- 原子性是通过 undo log（回滚日志） 来保证的；

- 隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；

- 一致性则是通过持久性+原子性+隔离性来保证；

  ![隔离级别](D:\Work\1513-Leetcode\Archive\pic\隔离级别.webp)

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

* 「读已提交」隔离级别是在「每个语句执行前」都会重新生成一个 Read View，而「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。

### 元数据锁

元数据锁(MDL)：当我们对数据库表进行操作时，会自动给这个表加上 MDL

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

### 意向锁

1. **意向共享锁（Intention Shared Lock, IS锁）**：当事务想要在某个行上加共享锁（S锁）时，它首先需要在相应的表上加一个IS锁。这表明该事务打算在表中的一行或多行上加共享锁。
2. **意向排他锁（Intention Exclusive Lock, IX锁）**：当事务想要在某行上加排他锁（X锁）时，它必须首先在相应的表上加一个IX锁。这表明该事务打算在表中的一行或多行上加排他锁。

意向锁的目的是为了快速判断表里是否有记录被加锁，意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。

### AUTO-INC 锁

- 当 innodb_autoinc_lock_mode = 0，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 innodb_autoinc_lock_mode = 2，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 innodb_autoinc_lock_mode = 1：
  - 普通 insert 语句，自增锁在申请之后就马上释放；
  - 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

### 行级锁

* Record Lock: 锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的；
* Gap Lock(间隙锁): 只存在于可重复读隔离级别，比如间隙锁(3,5)，其它事务就无法插入4了。**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。 
* Next-Key Lock(临键锁): Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身(3,5]

### 日志

- **undo log（回滚日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**原子性**，主要**用于事务回滚和 MVCC**。
- **redo log（重做日志）**：是 Innodb 存储引擎层生成的日志，实现了事务中的**持久性**，主要**用于掉电等故障恢复**；
- **binlog （归档日志）**：是 Server 层生成的日志，主要**用于数据备份和主从复制**；

Buffer Pool：

**InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的`16KB`的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页**。

![buffer](D:\Work\八股笔记\pic\buffer.webp)



### 两阶段提交

在多个数据库或资源上执行事务时，确保所有的参与者要么全部提交事务，要么全部回滚，以此来保持数据的一致性和完整性。

### 第一阶段：准备阶段（投票阶段）

1. **事务协调者开始**：事务的协调者（通常是发起事务的系统或应用）向所有参与当前事务的节点（可以是不同的数据库服务器）发送一个准备消息，询问它们是否准备好提交事务。
2. **参与者响应**：每个参与者（节点）接收到准备消息后，会执行事务操作，但不会立即提交。如果参与者可以成功执行事务（即没有违反约束或发生错误），它会向协调者回复一个"同意"（YES）的消息；如果不能成功执行，它会回复一个"拒绝"（NO）的消息。

### 第二阶段：提交阶段

- **如果所有参与者都同意提交**：协调者接收到所有参与者的"同意"响应后，会进入第二阶段，向所有参与者发送一个"提交"的消息。每个参与者收到提交消息后，会正式提交事务，然后向协调者发送一个"已提交"的确认。
- **如果任何参与者拒绝**：如果协调者从任何一个参与者那里接收到"拒绝"的响应，它会向所有参与者发送一个"回滚"的消息。每个参与者在收到回滚消息后，会撤销（回滚）其事务操作，并确认回滚完成。
